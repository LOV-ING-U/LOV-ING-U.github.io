---
title: "Project : RainMind 개발일지 - 11 [최적화 수행 기록]"
last_modified_at: 2026-02-14
# date: 2026-01-23 01:00:00 +0900
categories:
  - Rainmind
---  
  
1) 회원가입 기능  
유저 100명이, 3분동안 계속 회원가입 로직을 수행할 때를 모니터링해서 병목 지점이 있는지 찾고자 했다.  
우선 그냥 돌렸을때이다.  
![whyf](/pictures/grafana_signup/grafana_what/DBconnectpoolbef/why.JPG)
??? 응답시간이 k6 EC2에서는 거의 4초가 걸린다(쿼리 = 1000 *
(
  rate(http_server_requests_seconds_sum{job="rainmind-app", uri="/v1/auth/user/register"}[1m])
  /
  rate(http_server_requests_seconds_count{job="rainmind-app", uri="/v1/auth/user/register"}[1m])
)).  
  
output json을 뜯어보자.  
![whyfs](/pictures/grafana_signup/grafana_what/DBconnectpoolbef/3.JPG)  
찾았다.  
즉 회원가입 API에서 무거운 연산을 수행하기 때문에, 다른 요청들이 기다리는 시간이 거의 대부분이었던 것이다.  
  
혹시나 DB 커넥션 풀(Hikari 기본 = 10) 때문인지 궁금하여, application.yaml에 기본 커넥션 풀 사이즈를 5배 늘여서 해보았지만  
  
![whyfs2](/pictures/grafana_signup/grafana_what/DBconnectpoolaft/2.JPG)  
똑같았다. 또한 서버 EC2에서 top으로 CPU 사용량을 보았더니 97까지 치솟았다.  
  
따라서 회원가입 서비스 로직의 암호화 연산이 병목 지점임을 파악했다. gensalt 인자 값을 4로 주어(기본 = 10), CPU 연산을 훨씬 줄여보았고 결과는  
  
![yesyes](/pictures/grafana_signup/grafana_what/bcryptafter/ms.JPG)
![yesyess](/pictures/grafana_signup/grafana_what/bcryptafter/1.JPG)  
평균 응답시간 및 p(95)를 각각 3.68s, 3.96s -> 153.89ms, 415.77ms로, 거의 9배 가까이 개선할 수 있었다.  
  
그러나, BCrypt 인자를 4로 줄이는 것은, 연산량이 지수적으로 감소하기 때문에 보안적으로 매우 위험하다. 따라서, k8s의 자동 확장 기능 혹은, nginx 등을 이용하여 EC2 서버를 하나 더 띄운 다음 트래픽을 분산시키는 것이 적절한 조치임을 결론내렸다.  
  
2) 로그인 기능
  
